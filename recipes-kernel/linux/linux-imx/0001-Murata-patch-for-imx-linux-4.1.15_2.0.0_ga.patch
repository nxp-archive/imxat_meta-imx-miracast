From 17bc36560706ef769cf8bb2f036acd3a37d0f593 Mon Sep 17 00:00:00 2001
From: xlin <xlin@murata.com>
Date: Tue, 7 Feb 2017 14:30:46 -0600
Subject: [PATCH 1/4] Murata patch for imx-linux-4.1.15_2.0.0_ga. 1) HT avil
 fix 2) BT setting on IMX6SL 3) 1BW edge trigger

---
 arch/arm/boot/dts/imx6sl-evk-btwifi.dts         | 11 +++++
 arch/arm/boot/dts/imx7d-sdb.dts                 |  4 ++
 arch/arm/configs/imx_v7_defconfig               |  3 ++
 drivers/net/wireless/bcmdhd/Kconfig             |  4 ++
 drivers/net/wireless/bcmdhd/Makefile            | 10 ++++-
 drivers/net/wireless/bcmdhd/dhd_linux_platdev.c | 27 ++++++++-----
 drivers/net/wireless/bcmdhd/dhd_sdio.c          | 54 +++++++++++++++++++++----
 7 files changed, 95 insertions(+), 18 deletions(-)

diff --git a/arch/arm/boot/dts/imx6sl-evk-btwifi.dts b/arch/arm/boot/dts/imx6sl-evk-btwifi.dts
index b740c81..cbdf29d 100644
--- a/arch/arm/boot/dts/imx6sl-evk-btwifi.dts
+++ b/arch/arm/boot/dts/imx6sl-evk-btwifi.dts
@@ -48,6 +48,7 @@
 				MX6SL_PAD_SD1_DAT3__SD1_DATA3		0x17059
 				MX6SL_PAD_SD3_DAT1__GPIO5_IO20		0x13069 /* WL_HOST_WAKE */
 				MX6SL_PAD_SD3_DAT2__GPIO5_IO16		0x13069 /* WL_REG_ON */
+				MX6SL_PAD_SD3_DAT3__GPIO5_IO17		0x13069 /* BT_REG_ON */
 			>;
 		};
 
@@ -60,6 +61,16 @@
 		};
 	};
 };
+/* Murata: declare UART4 interface for Bluetooth. */
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_1>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+	/* for DTE mode, add below change */
+	/* fsl,dte-mode; */
+	/* pinctrl-0 = <&pinctrl_uart4dte_1>; */
+};
 
 &usdhc1 {
 	pinctrl-names = "default";
diff --git a/arch/arm/boot/dts/imx7d-sdb.dts b/arch/arm/boot/dts/imx7d-sdb.dts
index 8f03224..f9f422d 100644
--- a/arch/arm/boot/dts/imx7d-sdb.dts
+++ b/arch/arm/boot/dts/imx7d-sdb.dts
@@ -913,6 +913,8 @@
 				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x5a
 				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x5a
 				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x5a
+				MX7D_PAD_ECSPI2_MOSI__GPIO4_IO21	0x19 /* WL_REG_ON */
+				MX7D_PAD_ECSPI2_SCLK__GPIO4_IO20	0x19 /* WL_HOST_WAKE */
 			>;
 		};
 
@@ -924,6 +926,8 @@
 				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x5b
 				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x5b
 				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x5b
+				MX7D_PAD_ECSPI2_MOSI__GPIO4_IO21	0x19 /* WL_REG_ON */
+				MX7D_PAD_ECSPI2_SCLK__GPIO4_IO20	0x19 /* WL_HOST_WAKE */
 			>;
 		};
 
diff --git a/arch/arm/configs/imx_v7_defconfig b/arch/arm/configs/imx_v7_defconfig
index a7ab036..6ccbfcd 100644
--- a/arch/arm/configs/imx_v7_defconfig
+++ b/arch/arm/configs/imx_v7_defconfig
@@ -146,6 +146,9 @@ CONFIG_USB_USBNET=m
 CONFIG_USB_NET_CDC_EEM=m
 CONFIG_BCMDHD=y
 CONFIG_BCMDHD_SDIO=y
+# CONFIG_BCM43340 is not set
+# CONFIG_BCM4339 is not set
+# CONFIG_BCM4354 is not set
 CONFIG_BCMDHD_FW_PATH="/lib/firmware/bcm/ZP_BCM4339/fw_bcmdhd.bin"
 CONFIG_BCMDHD_NVRAM_PATH="/lib/firmware/bcm/ZP_BCM4339/bcmdhd.ZP.OOB.cal"
 # CONFIG_RTL_CARDS is not set
diff --git a/drivers/net/wireless/bcmdhd/Kconfig b/drivers/net/wireless/bcmdhd/Kconfig
index e5bc667..9868b3f 100644
--- a/drivers/net/wireless/bcmdhd/Kconfig
+++ b/drivers/net/wireless/bcmdhd/Kconfig
@@ -19,6 +19,10 @@ config BCM4339
 	tristate "BCM4339 support"
 	depends on BCMDHD
 
+config BCM43340 
+	tristate "BCM43340 support"
+	depends on BCMDHD
+
 config BCM4354
 	tristate "BCM4354 support"
 	depends on BCMDHD
diff --git a/drivers/net/wireless/bcmdhd/Makefile b/drivers/net/wireless/bcmdhd/Makefile
index e6ba661..7d6ab39 100644
--- a/drivers/net/wireless/bcmdhd/Makefile
+++ b/drivers/net/wireless/bcmdhd/Makefile
@@ -152,8 +152,14 @@ ifneq ($(CONFIG_BCM4339),)
   DHDCFLAGS += -DCUSTOM_PSPRETEND_THR=30
 endif
 
+# Murata: need the following define to handle BCM43340 edge interrupt (vs level interrupt on other chipsets).
+# Define is in imx_v7_defconfig.
+ifeq ($(CONFIG_BCM43340),)
+  DHDCFLAGS += -DHW_OOB
+endif
+
 ifneq ($(CONFIG_BCMDHD_SDIO),)
-  DHDCFLAGS += -DBDC -DOOB_INTR_ONLY -DDHD_BCMEVENTS -DMMC_SDIO_ABORT -DOOB_PARAM -DHW_OOB
+  DHDCFLAGS += -DBDC -DOOB_INTR_ONLY -DDHD_BCMEVENTS -DMMC_SDIO_ABORT -DOOB_PARAM 
   DHDCFLAGS += -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR -DDHD_VERSION_NO_DATE_TIME
 endif
 
@@ -161,8 +167,10 @@ ifneq ($(CONFIG_BCMDHD_PCIE),)
   DHDCFLAGS += -DPCIE_FULL_DONGLE -DBCMPCIE -DCUSTOM_DPC_PRIO_SETTING=-1
 endif
 
+# Murata: Un-comment next line for Optimization
 #EXTRA_LDFLAGS += --strip-debug
 
+# Murata: swap these lines depending on optimization -- comment debug flag to make code execution faster.
 EXTRA_CFLAGS += $(DHDCFLAGS) -DDHD_DEBUG
 EXTRA_CFLAGS += -DSRCBASE=\"$(src)\"
 EXTRA_CFLAGS += -I$(src)/include/ -I$(src)/
diff --git a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c b/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
index 8d68c42..e2132b2 100644
--- a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
+++ b/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
@@ -297,9 +297,9 @@ static int wifi_plat_dev_drv_probe(struct platform_device *pdev)
 	struct resource *resource;
 	wifi_adapter_info_t *adapter;
 #ifdef CONFIG_DTS
-#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+#if defined(OOB_INTR_ONLY)
 	int irq, gpio;
-#endif /* defined(OOB_INTR_ONLY) && defined (HW_OOB) */
+#endif /* defined(OOB_INTR_ONLY) */
 #endif /* CONFIG_DTS */
 
 	/* Android style wifi platform data device ("bcmdhd_wlan" or "bcm4329_wlan")
@@ -324,7 +324,7 @@ static int wifi_plat_dev_drv_probe(struct platform_device *pdev)
 		DHD_ERROR(("%s regulator is null\n", __FUNCTION__));
 		return -1;
 	}
-#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+#if defined(OOB_INTR_ONLY)
 	OOB_PARAM_IF(!dhd_oob_disable) {
 		/* This is to get the irq for the OOB */
 		gpio = of_get_gpio(pdev->dev.of_node, 0);
@@ -345,17 +345,26 @@ static int wifi_plat_dev_drv_probe(struct platform_device *pdev)
 			DHD_ERROR(("%s irq information is incorrect\n", __FUNCTION__));
 			return -1;
 		}
-		adapter->irq_num = irq;
 
-		/* need to change the flags according to our requirement */
-		adapter->intr_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL |
-			IORESOURCE_IRQ_SHAREABLE;
-	}
+	adapter->irq_num = irq;
 
+	/* need to change the flags according to our requirement */
+	adapter->intr_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL |
+		IORESOURCE_IRQ_SHAREABLE;
+	/* Murata -- HW_OOB define depends on chipset. HW_OOB makes host interrupt level-sensitive versus edge-sensitive.
+	 * ZP (BCM4339), 1DX (BCM4343W), 1FX (BCM43364), ZX/SN8000 (BCM43362) are level-sensitive (HW_OOB defined).
+	 * Type 1BW (BCM43340) is edge-sensitive (HW_OOB NOT defined).  
+	 */
+#ifdef HW_OOB /* HW_OOB defined means level sensitive interrupts */
+            adapter->intr_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL | IORESOURCE_IRQ_SHAREABLE;
+#else
+            adapter->intr_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE | IORESOURCE_IRQ_SHAREABLE;
+#endif /* HW_OOB */
+	}
 #if defined(OOB_PARAM)
 out:
 #endif /* defined(OOB_PARAM) */
-#endif /* defined(OOB_INTR_ONLY) && defined (HW_OOB) */
+#endif /* defined(OOB_INTR_ONLY) */
 #endif /* CONFIG_DTS */
 
 	wifi_plat_dev_probe_ret = dhd_wifi_platform_load();
diff --git a/drivers/net/wireless/bcmdhd/dhd_sdio.c b/drivers/net/wireless/bcmdhd/dhd_sdio.c
index 1207bb3..5124aae 100644
--- a/drivers/net/wireless/bcmdhd/dhd_sdio.c
+++ b/drivers/net/wireless/bcmdhd/dhd_sdio.c
@@ -66,6 +66,9 @@
 #include <dhdioctl.h>
 #include <sdiovar.h>
 
+/* Murata Work-around code for HT Avail failure (due to no external slow clk) */
+#define MURATA_WORKAROUND_FOR_HTAVAIL 1
+
 #ifdef PROP_TXSTATUS
 #include <dhd_wlfc.h>
 #endif
@@ -381,8 +384,8 @@ typedef struct dhd_bus {
 	bool		txglom_enable;	/* Flag to indicate whether tx glom is enabled/disabled */
 	uint32		txglomsize;	/* Glom size limitation */
 	void		*pad_pkt;
-#ifdef HW_OOB
-	int		bus_wake_on_resume; /* addition to fix suspend/resume powersave issue */
+#if defined(OOB_INTR_ONLY)
+	int		bus_wake_on_resume; /* Murata -- fix for suspend/resume powersave issue on i.MX architecture */
 #endif
 } dhd_bus_t;
 
@@ -1137,6 +1140,10 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 	bcmsdh_info_t *sdh;
 	uint32 delay = PMU_MAX_TRANSITION_DLY;
 
+#ifdef MURATA_WORKAROUND_FOR_HTAVAIL
+	int try_count, try_err;
+#endif /* MURATA_WORKAROUND_FOR_HTAVAIL */
+
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
 	clkctl = 0;
@@ -1218,6 +1225,10 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 			delay += PMU_TRANSITION_DLY_EXTRA;
 		}
 
+#ifdef MURATA_WORKAROUND_FOR_HTAVAIL
+	for (try_count = 0; try_count < 20; try_count++) { /* loop 20 times to test condition */
+		try_err = 0;
+#endif /* MURATA_WORKAROUND_FOR_HTAVAIL */
 		/* Otherwise, wait here (polling) for HT Avail */
 		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
 			SPINWAIT_SLEEP(sdioh_spinwait_sleep,
@@ -1228,14 +1239,37 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 		}
 		if (err) {
 			DHD_ERROR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
+#ifdef MURATA_WORKAROUND_FOR_HTAVAIL
+			try_err = 1; 
+#else
 			return BCME_ERROR;
+#endif /* MURATA_WORKAROUND_FOR_HTAVAIL */
 		}
 		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
 			DHD_ERROR(("%s: HT Avail timeout (%d): clkctl 0x%02x\n",
 			           __FUNCTION__, PMU_MAX_TRANSITION_DLY, clkctl));
+#ifdef MURATA_WORKAROUND_FOR_HTAVAIL
+			try_err = 1; 
+#else
 			return BCME_ERROR;
+#endif /* MURATA_WORKAROUND_FOR_HTAVAIL */
 		}
 
+#ifdef MURATA_WORKAROUND_FOR_HTAVAIL
+		if (try_err == 0) {
+			break;
+		}
+	} /* for (try_count = 0; try_count < 20; try_count++) */
+		if (try_err == 1) {
+			DHD_ERROR(("%s: HT Avail request error: retried %d times. UNRECOVERABLE!\n", __FUNCTION__, try_count));
+			return BCME_ERROR;
+		}
+		else {
+			if(try_count > 0)
+				DHD_ERROR(("%s: HT Avail request NO ERROR: retried %d times.\n", __FUNCTION__, try_count));
+		}
+#endif /* MURATA_WORKAROUND_FOR_HTAVAIL */
+
 		/* Mark clock available */
 		bus->clkstate = CLK_AVAIL;
 		DHD_INFO(("CLKCTL: turned ON\n"));
@@ -1888,6 +1922,10 @@ static int dhdsdio_txpkt_preprocess(dhd_bus_t *bus, void *pkt, int chan, int txs
 		PKTALIGN(osh, tmp_pkt, PKTLEN(osh, pkt), DHD_SDALIGN);
 		bcopy(PKTDATA(osh, pkt), PKTDATA(osh, tmp_pkt), PKTLEN(osh, pkt));
 		*new_pkt = tmp_pkt;
+		/* pull back sdpcm_hdrlen length from old skb as new skb here is passed
+		 * to postprocessing
+		 */
+		PKTPULL(osh, pkt, sdpcm_hdrlen);
 		pkt = tmp_pkt;
 	}
 
@@ -6539,13 +6577,15 @@ dhd_bus_watchdog(dhd_pub_t *dhdp)
 	DHD_TIMER(("%s: Enter\n", __FUNCTION__));
 
 	bus = dhdp->bus;
-#ifdef HW_OOB
-	/* this code segment added to fix suspend/resume powersave issue */
+
+/* Murata -- fix for suspend/resume powersave issue on i.MX architecture */
+#if defined(OOB_INTR_ONLY)
 	if (bus->bus_wake_on_resume) {
 		BUS_WAKE(bus);
 		bus->bus_wake_on_resume = 0;
 	}
 #endif
+
 	if (bus->dhd->dongle_reset)
 		return FALSE;
 
@@ -7516,12 +7556,10 @@ dhdsdio_resume(void *context)
 		if (dhd_os_check_if_up(bus->dhd))
 			bcmsdh_oob_intr_set(bus->sdh, TRUE);
 	}
-#endif 
-#ifdef HW_OOB
-	/* this code segment added to fix suspend/resume powersave issue */
+	/* Murata -- fix for suspend/resume powersave issue on i.MX architecture: add next two lines of code. */
 	bus->bus_wake_on_resume = 1;
 	dhd_os_wd_timer(bus->dhd, 1000);
-#endif
+#endif 
 	return 0;
 }
 
-- 
1.9.1

